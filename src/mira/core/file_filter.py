"""File filtering for diff review."""

from __future__ import annotations

import fnmatch

from mira.config import FilterConfig
from mira.models import FileChangeType, FileDiff

_GENERATED_MARKERS = [
    "DO NOT EDIT",
    "AUTO-GENERATED",
    "AUTOGENERATED",
    "Generated by",
    "automatically generated",
    "This file is generated",
    "@generated",
]


def _is_generated(file_diff: FileDiff) -> bool:
    """Heuristic check for generated files."""
    for hunk in file_diff.hunks[:2]:
        content_upper = hunk.content[:500].upper()
        for marker in _GENERATED_MARKERS:
            if marker.upper() in content_upper:
                return True
    return False


def _matches_any_pattern(path: str, patterns: list[str]) -> bool:
    """Check if path matches any of the glob patterns."""
    filename = path.rsplit("/", 1)[-1] if "/" in path else path
    for pattern in patterns:
        if fnmatch.fnmatch(path, pattern) or fnmatch.fnmatch(filename, pattern):
            return True
    return False


def _sort_priority(file_diff: FileDiff) -> tuple[int, int]:
    """Sort key: modified files first, then by size (larger first)."""
    type_order = {
        FileChangeType.MODIFIED: 0,
        FileChangeType.ADDED: 1,
        FileChangeType.RENAMED: 2,
        FileChangeType.DELETED: 3,
    }
    return (type_order.get(file_diff.change_type, 4), -file_diff.total_changes)


def filter_files(files: list[FileDiff], config: FilterConfig) -> list[FileDiff]:
    """Filter files based on configuration rules.

    Excludes binary files, pattern-matched files, deleted files (if configured),
    and generated files. Then caps at max_files with priority sorting.
    """
    result: list[FileDiff] = []
    for f in files:
        if f.is_binary:
            continue
        if config.exclude_deleted and f.change_type == FileChangeType.DELETED:
            continue
        if _matches_any_pattern(f.path, config.exclude_patterns):
            continue
        if _is_generated(f):
            continue
        result.append(f)

    result.sort(key=_sort_priority)

    if len(result) > config.max_files:
        result = result[: config.max_files]

    return result
